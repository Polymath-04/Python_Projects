# Error Scenarios 
# Invalid Segment
# Invalid Column Name

# Error Types
# exception KeyError
# Raised when a mapping (dictionary) key is not found in the set of existing keys.

# exception ValueError
# Raised when an operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError.

# exception ConnectionRefusedError
# A subclass of ConnectionError, raised when a connection attempt is refused by the peer. Corresponds to errno ECONNREFUSED.

# exception FileNotFoundError
# Raised when a file or directory is requested but doesnâ€™t exist. Corresponds to errno ENOENT.

# exception UserWarning
# Base class for warnings generated by user code



# Code Snippets


class MyCustomError(Exception):
    """Exception raised for custom error in the application."""

    def __init__(self, message, error_code):
        super().__init__(message)
        self.error_code = error_code

    def __str__(self):
        return f"{self.message} (Error Code: {self.error_code})"

def divide(a, b):
    if b == 0:
        raise MyCustomError("Division by zero is not allowed", 400)
    return a / b

try:
    result = divide(10, 0)
except MyCustomError as e:
    print(f"Caught an error: {e}")


class FileProcessingError(Exception):
    def __init__(self, message, filename, lineno):
        super().__init__(message)
        self.filename = filename
        self.lineno = lineno

    def __str__(self):
        return f"{self.message} in {self.filename} at line {self.lineno}"


try:
    raise FileProcessingError("Syntax error", "example.txt", 13)
except FileProcessingError as e:
    print(f"Caught an error: {e}")